from dotenv import load_dotenv
from fastapi import APIRouter, Depends, Form, HTTPException
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr
from email.message import EmailMessage
from openai import OpenAI
import aiosmtplib
import json
import os

from .models import User, Response, ArchivedResponse, Feedback, FormModel, RoundModel, UserFormUnlock
from .auth import (
    get_db,
    get_password_hash,
    verify_password,
    create_access_token,
    get_current_user,
    get_current_admin_user,
)
from consensus.ws import ws_manager

load_dotenv()


router = APIRouter()

client = OpenAI(
    api_key=os.getenv("OPENROUTER_API_KEY"),
    base_url="https://openrouter.ai/api/v1"
)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


# ---------------------------------------------------------
# USER AUTH
# ---------------------------------------------------------

@router.post("/register")
def register(
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db),
):
    if db.query(User).filter(User.email == email).first():
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = get_password_hash(password)
    user = User(email=email, hashed_password=hashed)
    db.add(user)
    db.commit()
    return {"message": "Registered successfully"}


@router.post("/login")
def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.email == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    token = create_access_token(
        data={"sub": str(user.id), "is_admin": user.is_admin}
    )

    return {
        "access_token": token,
        "token_type": "bearer",
        "is_admin": user.is_admin,
        "email": user.email
    }


@router.get("/me")
def me(user: User = Depends(get_current_user)):
    return {"email": user.email, "is_admin": user.is_admin}


# ---------------------------------------------------------
# SUBMIT RESPONSE (Delphi style)
# ---------------------------------------------------------

@router.post("/submit")
def submit_response(
    form_id: int = Form(...),
    answers: str = Form(...),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    active_round = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )

    if not active_round:
        raise HTTPException(status_code=400, detail="No active round")

    # Check if user has already submitted for this round, and delete old response if so
    existing_response = db.query(Response).filter(
        Response.user_id == user.id,
        Response.round_id == active_round.id
    ).first()
    if existing_response:
        db.delete(existing_response)
        db.commit()

    data = json.loads(answers)

    new = Response(
        form_id=form_id,
        user_id=user.id,
        round_id=active_round.id,
        answers=data,
    )
    db.add(new)

    archive = ArchivedResponse(
        form_id=form_id,
        user_id=user.id,
        email=user.email,
        answers=data,
        round_id=active_round.id,
    )
    db.add(archive)

    db.commit()
    return {"ok": True}


@router.get("/has_submitted")
def has_submitted(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    active_round = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )
    if not active_round:
        return {"submitted": False}

    r = db.query(Response).filter(
        Response.user_id == user.id,
        Response.round_id == active_round.id
    ).first()
    return {"submitted": bool(r)}


@router.get("/form/{form_id}/my_response")
def get_my_response(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    active_round = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )
    if not active_round:
        raise HTTPException(status_code=404, detail="No active round")

    response = db.query(Response).filter(
        Response.user_id == user.id,
        Response.round_id == active_round.id
    ).first()

    if not response:
        raise HTTPException(status_code=404, detail="No response found")

    return {"answers": response.answers}


# ---------------------------------------------------------
# FEEDBACK
# ---------------------------------------------------------

class FeedbackPayload(BaseModel):
    accuracy: str
    influence: str
    furtherThoughts: str
    usability: str


@router.post("/submit_feedback")
def submit_feedback(
    feedback: FeedbackPayload,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    try:
        with open("summary_cache.txt") as f:
            summary_html = f.read().strip()
    except FileNotFoundError:
        summary_html = ""

    entry = Feedback(
        accuracy=feedback.accuracy,
        influence=feedback.influence,
        further_thoughts=feedback.furtherThoughts,
        usability=feedback.usability,
        summary=summary_html,
        user_id=user.id
    )
    db.add(entry)
    user.has_submitted_feedback = True
    db.commit()
    return {"message": "Feedback saved"}


@router.get("/all_feedback")
def all_feedback(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    f = db.query(Feedback).order_by(Feedback.created_at.desc()).all()

    return [
        {
            "accuracy": x.accuracy,
            "influence": x.influence,
            "usability": x.usability,
            "furtherThoughts": x.further_thoughts,
            "summary": x.summary,
            "email": x.user.email,
            "timestamp": x.created_at.isoformat()
        }
        for x in f
    ]


# ---------------------------------------------------------
# SUMMARY (SYNTHESIS)
# ---------------------------------------------------------

class SummaryPayload(BaseModel):
    summary: str


@router.post("/forms/{form_id}/push_summary")
async def push_summary(
    form_id: int,
    payload: SummaryPayload,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    summary = payload.summary.strip()

    active_round = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )

    if not active_round:
        raise HTTPException(status_code=400, detail="No active round")

    active_round.synthesis = summary
    db.commit()

    with open("summary_cache.txt", "w") as f:
        f.write(summary)

    await ws_manager.broadcast_summary(summary)

    return {"detail": "Summary pushed"}


class GenerateSummaryPayload(BaseModel):
    model: str


@router.post("/forms/{form_id}/generate_summary")
def generate_summary(
    form_id: int,
    payload: GenerateSummaryPayload,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    active_round = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )

    if not active_round:
        raise HTTPException(status_code=400, detail="No active round")

    # Fetch questions for the active round
    questions = active_round.questions or []
    if not questions:
        form = db.query(FormModel).filter(FormModel.id == form_id).first()
        if form:
            questions = form.questions or []

    if not questions:
        raise HTTPException(status_code=400, detail="No questions found for this round")

    # Fetch responses for the active round
    responses = (
        db.query(Response)
        .filter(Response.round_id == active_round.id)
        .order_by(Response.created_at.asc())
        .all()
    )

    if not responses:
        raise HTTPException(status_code=404, detail="No responses to summarize")

    # Prepare the content for the LLM
    prompt_content = "Please synthesize the following responses to the questions that were asked.\n\n"
    prompt_content += "Questions:\n"
    for i, q in enumerate(questions, 1):
        prompt_content += f"{i}. {q}\n"
    
    prompt_content += "\n--- Responses ---\n"

    for i, r in enumerate(responses, 1):
        prompt_content += f"\nResponse {i}:\n"
        for q_idx, q_text in enumerate(questions, 1):
            answer = r.answers.get(f'q{q_idx}', 'No answer')
            prompt_content += f"  - Q: {q_text}\n"
            prompt_content += f"    A: {answer}\n"

    prompt_content += "\n--- End of Responses ---\n"
    prompt_content += "\nNow, please provide a concise synthesis of all the answers."

    try:
        completion = client.chat.completions.create(
            model=payload.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are an expert at synthesizing and summarizing responses.",
                },
                {"role": "user", "content": prompt_content},
            ],
        )
        summary = completion.choices[0].message.content
        return {"summary": summary}
    except Exception as e:
        # Log the error for debugging
        print(f"Error calling OpenRouter: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate summary: {e}")



# ---------------------------------------------------------
# FORM MANAGEMENT
# ---------------------------------------------------------

class FormCreate(BaseModel):
    title: str
    questions: list[str]
    allow_join: bool
    join_code: str


class FormUpdate(BaseModel):
    title: str
    questions: list[str]


@router.post("/create_form")
def create_form(
    payload: FormCreate,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    f = FormModel(
        title=payload.title,
        questions=payload.questions,
        allow_join=payload.allow_join,
        join_code=payload.join_code
    )
    db.add(f)
    db.commit()
    db.refresh(f)

    first_round = RoundModel(
        form_id=f.id,
        round_number=1,
        is_active=True,
        questions=payload.questions
    )
    db.add(first_round)
    db.commit()

    return {
        "id": f.id,
        "title": f.title,
        "questions": f.questions,
        "allow_join": f.allow_join,
        "join_code": f.join_code,
        "participant_count": 0,
        "current_round": 1
    }


@router.put("/forms/{form_id}")
def update_form(
    form_id: int,
    payload: FormUpdate,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    f = db.query(FormModel).filter(FormModel.id == form_id).first()
    if not f:
        raise HTTPException(status_code=404, detail="Form not found")

    f.title = payload.title
    f.questions = payload.questions
    db.commit()
    return {"status": "updated"}


@router.delete("/forms/{form_id}")
def delete_form(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    # Now delete the form itself
    f = db.query(FormModel).filter(FormModel.id == form_id).first()
    if not f:
        raise HTTPException(status_code=404, detail="Form not found")

    db.delete(f)
    db.commit()
    return {"status": "deleted"}


@router.get("/forms")
def get_forms(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    items = db.query(FormModel).order_by(FormModel.id).all()

    result = []
    for f in items:
        participant_count = db.query(Response.user_id).filter(Response.form_id == f.id).distinct().count()
        
        active_round = db.query(RoundModel).filter(
            RoundModel.form_id == f.id,
            RoundModel.is_active == True
        ).first()
        
        result.append({
            "id": f.id,
            "title": f.title,
            "questions": f.questions,
            "allow_join": f.allow_join,
            "join_code": f.join_code,
            "participant_count": participant_count,
            "current_round": active_round.round_number if active_round else 0
        })

    return result


class UnlockFormPayload(BaseModel):
    join_code: str


@router.post("/forms/unlock")
def unlock_form(
    payload: UnlockFormPayload,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    form = db.query(FormModel).filter(
        FormModel.join_code == payload.join_code,
        FormModel.allow_join == True
    ).first()
    
    if not form:
        raise HTTPException(status_code=404, detail="Form not found or closed.")

    # Check if user has already unlocked this form
    existing_unlock = db.query(UserFormUnlock).filter(
        UserFormUnlock.user_id == user.id,
        UserFormUnlock.form_id == form.id
    ).first()

    if existing_unlock:
        return {"message": "Form already unlocked."}

    # Create a new unlock record
    new_unlock = UserFormUnlock(user_id=user.id, form_id=form.id)
    db.add(new_unlock)
    db.commit()
        
    return {"message": "Form unlocked successfully."}


@router.get("/my_forms")
def get_my_forms(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    unlocked_forms = db.query(FormModel).join(UserFormUnlock).filter(UserFormUnlock.user_id == user.id).order_by(FormModel.id).all()
    return unlocked_forms


@router.get("/forms/{form_id}")
def get_form(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    f = db.query(FormModel).filter(FormModel.id == form_id).first()
    if not f:
        raise HTTPException(status_code=404, detail="Form not found")

    return {
        "id": f.id,
        "title": f.title,
        "questions": f.questions,
        "allow_join": f.allow_join,
        "join_code": f.join_code
    }


# ---------------------------------------------------------
# ROUNDS (Delphi)
# ---------------------------------------------------------

class RoundConfig(BaseModel):
    questions: list[str] | None = None


@router.get("/forms/{form_id}/active_round")
def get_active_round(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    active = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )
    if not active:
        raise HTTPException(status_code=404, detail="No active round")

    prev = (
        db.query(RoundModel)
        .filter(
            RoundModel.form_id == form_id,
            RoundModel.round_number == active.round_number - 1
        )
        .first()
    )

    previous_round_synthesis = prev.synthesis if prev else ""

    return {
        "id": active.id,
        "round_number": active.round_number,
        "questions": active.questions or [],
        "previous_round_synthesis": previous_round_synthesis
    }



@router.post("/forms/{form_id}/next_round")
def open_next_round(
    form_id: int,
    payload: RoundConfig | None = None,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    current = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )

    if current:
        current.is_active = False

    last = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id)
        .order_by(RoundModel.round_number.desc())
        .first()
    )

    next_number = (last.round_number + 1) if last else 1

    form = db.query(FormModel).filter(FormModel.id == form_id).first()
    base = form.questions or []

    if payload and payload.questions:
        questions = payload.questions
    elif last and last.questions:
        questions = last.questions
    else:
        questions = base

    previous_synthesis = last.synthesis if last and last.synthesis else ""

    new = RoundModel(
        form_id=form_id,
        round_number=next_number,
        is_active=True,
        questions=questions,
        synthesis=previous_synthesis
    )
    db.add(new)
    db.commit()
    db.refresh(new)

    return {
        "id": new.id,
        "round_number": new.round_number,
        "questions": new.questions
    }



@router.get("/forms/{form_id}/rounds")
def get_rounds(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    rounds = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id)
        .order_by(RoundModel.round_number.asc())
        .all()
    )

    return [
        {
            "id": r.id,
            "round_number": r.round_number,
            "synthesis": r.synthesis,
            "is_active": r.is_active,
            "questions": r.questions or []
        }
        for r in rounds
    ]


# ---------------------------------------------------------
# RESPONSES
# ---------------------------------------------------------

@router.get("/form/{form_id}/responses")
def form_responses(
    form_id: int,
    all_rounds: bool = False,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    q = db.query(Response).filter(Response.form_id == form_id)

    if not all_rounds:
        active = (
            db.query(RoundModel)
            .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
            .first()
        )
        if active:
            q = q.filter(Response.round_id == active.id)

    items = q.order_by(Response.created_at.asc()).all()

    return [
        {
            "answers": x.answers,
            "email": x.user.email if x.user else None,
            "timestamp": x.created_at.isoformat(),
            "round_id": x.round_id
        }
        for x in items
    ]


@router.get("/form/{form_id}/archived_responses")
def form_archived(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    items = (
        db.query(ArchivedResponse)
        .filter(ArchivedResponse.form_id == form_id)
        .order_by(ArchivedResponse.created_at.asc())
        .all()
    )

    return [
        {
            "answers": x.answers,
            "email": x.email,
            "timestamp": x.created_at.isoformat(),
            "round_id": x.round_id
        }
        for x in items
    ]


@router.get("/forms/{form_id}/rounds_with_responses")
def rounds_with_responses(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    rounds = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id)
        .order_by(RoundModel.round_number.asc())
        .all()
    )

    output = []
    for r in rounds:
        rs = (
            db.query(Response)
            .filter(Response.round_id == r.id)
            .order_by(Response.created_at.asc())
            .all()
        )

        output.append({
            "id": r.id,
            "round_number": r.round_number,
            "synthesis": r.synthesis,
            "is_active": r.is_active,
            "responses": [
                {
                    "answers": x.answers,
                    "email": x.user.email if x.user else None,
                    "timestamp": x.created_at.isoformat()
                }
                for x in rs
            ]
        })

    return output


# ---------------------------------------------------------
# GENERIC SYNTHESIS
# ---------------------------------------------------------

@router.post("/form/{form_id}/synthesise")
def synthesise_simple(
    form_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_admin_user)
):
    active = (
        db.query(RoundModel)
        .filter(RoundModel.form_id == form_id, RoundModel.is_active == True)
        .first()
    )

    if not active:
        raise HTTPException(status_code=400, detail="No active round")

    items = (
        db.query(Response)
        .filter(Response.round_id == active.id)
        .order_by(Response.created_at.asc())
        .all()
    )

    if not items:
        return {"summary": "No responses yet"}

    blocks = []
    for i, r in enumerate(items, start=1):
        parts = []
        for key, val in r.answers.items():
            clean = str(val).replace("\n", "<br/>")
            parts.append(f"<p><strong>{key}</strong>: {clean}</p>")

        blocks.append(f"<div><h3>Response {i}</h3>{''.join(parts)}</div>")

    html = "<p><strong>All responses:</strong></p>" + "".join(blocks)
    return {"summary": html}


# ---------------------------------------------------------
# EMAIL
# ---------------------------------------------------------

class EmailRequest(BaseModel):
    to: EmailStr
    subject: str
    html: str


@router.post("/send_email")
async def send_email(
    to: str = Form(...),
    subject: str = Form(...),
    html: str = Form(...),
    user: User = Depends(get_current_admin_user)
):
    # This function requires the following environment variables to be set in the .env file:
    # SMTP_HOST: The hostname of the SMTP server.
    # SMTP_PORT: The port of the SMTP server.
    # SMTP_USER: The username for the SMTP server.
    # SMTP_PASS: The password for the SMTP server.
    msg = EmailMessage()
    msg["From"] = "info@colabintel.org"
    msg["To"] = to
    msg["Subject"] = subject
    msg.set_content(html, subtype="html")

    try:
        await aiosmtplib.send(
            msg,
            hostname=os.getenv("SMTP_HOST"),
            port=int(os.getenv("SMTP_PORT", "587")),
            start_tls=True,
            username=os.getenv("SMTP_USER"),
            password=os.getenv("SMTP_PASS")
        )
        return {"status": "sent"}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed: {str(e)}")
